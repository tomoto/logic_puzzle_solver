## コーディングスタイルなど

- 式の途中で改行する際には演算子が次の行に来るようにする

  - Prettier 風; やってみて実際にいいかどうか判断

- inline

  - 性能のため inline にしたいものは多いが、デフォルトで inline になるものは付けない
  - ヘッダ内で値を定義する non-const なクラススタティック変数には付ける(i.e. inline static)
    - static const はリンクエラーになったりならなかったりするので static constexpr 推奨
  - ヘッダ内で定義する非テンプレート関数は付ける
    - 付けないとリンクエラーになる
  - ソース内で定義する static な補助関数はインライン展開したいか判断して付ける

- constexpr

  - ユーティリティ系の基盤データ構造はなるべく constexpr にしておく

### クラス定義

- データメンバの private 化にはこだわらない
  - 「解答マシンはデータ構造の実装詳細を知っていて当然」という世界観でよい
  - 余計な getter/setter は書かない; アクセス用 syntax sugar はあってもよい
  - JavaScript とか Python とか private なしにやってる言語から学ぶこともあろう
- 故に "we prefer struct to class"
- const 性にも常にこだわらず、コーディングが楽になるように判断
  - 解答処理でがちゃがちゃいじくり回すクラスは基本 non-const で扱った方が楽
- ユーティリティ系関数は struct の static メンバにするか namespace に入れるか悩む
  - namespace が好ましいと言われるので、基本的にはそうしてみる
  - namespace にはデメリットもある: 定義順に制約が生じる、inline 展開やテンプレートのためヘッダで定義すると private な補助関数を持てない、など
- 基本 value-semantics で設計し、大きなデータは movable & uncopiable にして move のみで引き回す
  - movable & uncopiable にすることで、意図しないコピーをコンパイル時に検出できる
  - 「明示的なコピーのみ可」にしたい場合、コピーコンストラクタを private にし、duplicate メソッドでラップする

### オブジェクト初期化

C++11 以降の仕様拡張でオブジェクト初期化の方法が乱立して困る。経験的にリーズナブルと思われるガイドラインを示す。

#### TL;DR

- その 1: 基本型や単一の値に見えるもの: `T x = ...`

  ```
  int x = 123;
  std::string x = "hoge";

  // 型が導出できれば左辺はautoでもよい
  auto x = 123;
  auto x = "hoge"s;
  ```

- その 2: 配列や構造体、それに準ずるコンテナにデータを与えて構築するイメージの場合: `T x = {...}`

  ```
  std::vector v = {1, 2, 3};
  std::pair customer = {333, "Yamada"s};

  struct Point { int x, y; };
  Point p = {3, 3};
  ```

(例: std::vector や std::pair)にデータを与えて構築する場合は `T x = {value, value, ...}`

- その 3: それが保持するデータと直接関係のないパラメタを与えて構築する場合は `T x(...)`

最近の言語仕様でやり方が乱立していて困るので、一定のガイドラインを定める

- その 1: `=` を使うケース

  - 基本型(int とか)や単一の値に見えるもの(string とか)
  - 無理して変えると認知負荷が高すぎる

- その 2: `{...}` を使うケース

  - 配列っぽいもの
    - std::vector v{1, 2, 3};
  - コンストラクタを定義しない手抜き集成体(c.f. `struct Point { int x; int y; }`)
    - struct Point
  - 複数の値を突っ込んで構築するイメージの設計もの(c.f. `std::pair`)
  - 変数宣言での構文: (a)`T v = {...}` (b)`auto v = T{...}` (c)`T v{...}` の中では(a)が望ましい
    - (b) は左辺が auto で揃うというメリットがあるが、使えない文脈がどうしても発生する(c.f. メンバ初期化)
    - (c) は単純に違和感の問題; (a)の方が馴染みがあり、その 1 とも揃う
  - return での構文: `T f() { return {...}; }` と `auto f() { return T{...}; }` なら前者が望ましい
    - 後者は戻り値推論が期待通り動かないケースが発生する(concept のチェックの際に発生した気がする)

- その 3: `(...)` を使うケース

  - カスタムコンストラクタが定義されており、値を突っ込んでいるというよりは関数呼び出しイメージの場合(c.f. `std::vector(int size, T value)`)
  - 変数宣言での構文: `T v()` と `auto v = T()` であれば前者が望ましい(理由は前述の通り)
  - メンバ初期化の文脈、引数に渡す文脈、return の文脈では、型名を繰り返さないためケースバイケースで別の構文にフォールバックしてもよい
    - c.f. `T x = T(...)` -> `T x = {...}`
    - c.f. `T f() { return T(...); }` -> `T f() { return {...}; }` or `auto f() { return T(); }`
    - c.f. `v.push_back(T(...))` -> `v.push_back({...})`
    - 言語仕様やわかりやすさとの兼ね合いで、何がいいかは一概には言えない
